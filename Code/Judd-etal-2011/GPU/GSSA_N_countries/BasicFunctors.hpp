#ifndef _BASIC_FUNCTORS_H_
#define _BASIC_FUNCTORS_H_

#include <thrust/iterator/zip_iterator.h>
#include <thrust/for_each.h>

template <typename T>
struct productivity_functor
{
  const T rho;
  const T eps;
  productivity_functor(T _rho, T _eps) : rho(_rho), eps(_eps) {}

  __host__ __device__
  T operator()(const T& a) const 
  { 
    return ((T)std::pow(a, rho))*((T)std::exp(eps));
  }
};


template <typename T>
struct dividend_functor
{
    const float baseVal;
    const float div_even;
    const float div_odd;
    dividend_functor(float _baseVal, float _dive, float _divo) : 
        baseVal(_baseVal), div_even(_dive), div_odd(_divo) {}

    __host__ __device__
        T operator()(const int& x) const 
        { 
            // Start off with the base value
            T retval = (T) baseVal;

            // Get the node ID.  Remember this is being generated by
            // the counting iterator and corresponds to the node in the
            // tree.
            int node_id = x;
            while (node_id != 0) {
                if (node_id % 2 == 0) { // node_id is even
                    retval *= div_even;
                } else { // node_id is odd
                    retval *= div_odd;
                }
                node_id = (node_id - 1) / 2;
            }
            return retval;
        }
};

template <typename T>
struct probability_functor
{
    const float baseVal;
    const float prob_lolo;
    const float prob_hihi;
    const float init_prob_lo;
    probability_functor(float _baseVal, float _probl, float _probh, float _iprobl) : 
        baseVal(_baseVal), prob_lolo(_probl), prob_hihi(_probh), init_prob_lo(_iprobl) {}

    __host__ __device__
        T operator()(const int& x) const 
        { 
            // Start off with the base value
            T retval = (T) baseVal;

            // Get the node ID.  Remember this is being generated by
            // the counting iterator and corresponds to the node in the
            // tree.
            int node_id = x;
            int parent_id;
            while(node_id != 0){
                parent_id = (node_id - 1) / 2;
                if (node_id > 2) { // must be third gen or later
                    if (node_id % 2 == 0) { // node_id is even
                        if (parent_id % 2 == 0) { // parent node is even
                            retval *= prob_hihi;
                        } else { // parent node is odd
                            retval *= (1 - prob_lolo);
                        }
                    } else { // node_id is odd
                        if (parent_id % 2 == 0) { // parent node is even
                            retval *= (1 - prob_hihi);
                        } else { // parent node is odd
                            retval *= prob_lolo;
                        }
                    }
                } else {
                    if (node_id % 2 == 0) { // node id is even and second gen
                        retval *= (1 - init_prob_lo);
                    } else { // node id is odd
                        retval *= init_prob_lo;
                    }
                }
                node_id = parent_id;
            }
            return retval;
        }
};

template <typename T>
struct euler_functor
{
    const T* bet;
    const T* gam;
    const T* mu;
    const T* consInit;
    const int nAgents;
    const int nStates;
    const float newtonTol;

    euler_functor(T * _bet, T * _gam, T * _mu, T * _consInit, int _nAgents,             
            int _nStates, float _newtonTol) :
        bet(_bet), gam(_gam), mu(_mu), consInit(_consInit), nAgents(_nAgents), 
        nStates(_nStates), newtonTol(_newtonTol) {}

    template <typename Tuple>
    __host__ __device__
        void operator()(Tuple t)
        { 
            // Now that we are using a tuple (and there are multiple vectors being used), you
            // access them with thrust::get<x>(t) where x is the position in the zip iterator
            // and t is the tuple itself.
            // For this the zip order is:
            // 0: x, the number of the state
            // 1: dividends
            // 2: probsType1
            // 3: probsType2
            // 4: consType1
	    // 5. consType2
	    // 6. prices
            
            // compute weights (xi) that scale consumption choices in Eqn (22) of the paper	  
            T xi[2];
            T probs[2];
            probs[0] = thrust::get<2>(t); // I need to generalize this so that it can scale up to nAgents
            probs[1] = thrust::get<3>(t);
            const int period = (int)(logf(thrust::get<0>(t)+1) / logf(nStates));
	    for(int i = 0 ; i < nAgents ; ++i){
	      xi[i] = powf(powf(bet[i]/bet[0], period)*probs[i]/probs[0], 1/gam[i])*consInit[i]/powf(consInit[0], gam[0]/gam[i]);
            }

            // check to see if all of the risk aversion coefficients are equal
            int gamCheck = 0;
            for(int i = 1 ; i < nAgents ; ++i){
                if(gam[i] != gam[0]){
                    ++gamCheck;
                }
            }

            // if risk aversion coefficients are equal, use analytical solution
            if(gamCheck == 0){
                T sumWeights = 0.0;
                for(int i = 0 ; i < nAgents ; ++i){
                    sumWeights += mu[i]*xi[i];
                    thrust::get<4>(t) = thrust::get<1>(t)/sumWeights;
                }

                // else Newton's method
            } else {

                // initialize 
                T cons_now = consInit[0];
                T fVal = thrust::get<1>(t);
                T dfVal;
                T cons_next;
                while(fabs(fVal) > newtonTol){

                    // compute function and derivative at current value
                    fVal = thrust::get<1>(t);
                    dfVal = 0.0;
                    for(int i = 0 ; i < nAgents ; ++i){
                        fVal -= mu[i]*xi[i]*pow(cons_now, gam[0]/gam[i]);
                        dfVal -= (gam[0]/gam[i])*mu[i]*xi[i]*pow(cons_now, (gam[0]/gam[i])-1);
                    }

                    // update consumption value
                    cons_next = cons_now - fVal/dfVal;
                }
                thrust::get<4>(t) = cons_next;
            }
	    thrust::get<5>(t) = xi[1]*pow(thrust::get<4>(t), gam[0]/gam[1]); // need to generalize this to nagents
	    thrust::get<6>(t) = powf(bet[0], period)*powf(thrust::get<4>(t)/consInit[0], -gam[0])*thrust::get<2>(t);
        }
};


template <typename T>
struct excess_wealth_functor
{

    template <typename Tuple>
    __host__ __device__
        T operator()(Tuple t)
        { 
            // For this the zip order is:
            // 0: prices
            // 1: dividends
            // 2: consumption
	    return thrust::get<0>(t)*(thrust::get<1>(t) - thrust::get<2>(t));
	}
};


#endif //BASICFUNCTORS_H
